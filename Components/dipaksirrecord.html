<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dipak Sir's PCB Record</title>
    <link rel="stylesheet" href="https://handsontable.com/static/css/main.css">
    <style>
        .htCenter {
            text-align: center;
        }

        .bold {
            font-weight: bold;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
        }

        #container {
            margin: 0 auto;
            width: 80%;
        }

        /* Styling for summary table */
#summaryTable {
    width: 100%;
    border-collapse: collapse;
    margin-top: 20px;
}

#summaryTable th, #summaryTable td {
    border: 1px solid #dddddd;
    padding: 8px;
    text-align: left;
}

#summaryTable th {
    background-color: #f2f2f2;
}

#summaryTable tr:nth-child(even) {
    background-color: #f9f9f9;
}

#summaryTable tr:hover {
    background-color: #e9e9e9;
}

    </style>
</head>

<body>
    <div id="container">
        <h1>Dipak Sir has these PCBs</h1>

        <div id="summaryContainer" style="margin-top: 20px; display: none;">
            <h2>Summary of PCBs and Quantities</h2>
            <div id="summaryTable"></div>
        </div>
        
        
        <label for="pcbSelect">Select PCB: </label>
        <select id="pcbSelect">
            <option value="">Select PCB</option>
            <option value="Power">Power</option>
            <option value="Lamp">Lamp</option>
            <option value="Buzzer">Buzzer</option>
            <option value="Invert">Invert</option>
            <option value="Dark">Dark</option>
            <option value="Distance">Distance</option>
            <option value="IR">IR</option>
            <option value="Motor Driver">Motor Driver</option>
            <option value="Wire Tap">Wire Tap</option>
            <option value="Button">Button</option>
            <option value="AI">AI</option>
            <option value="Wifi Clip V1">Wifi Clip V1</option>
            <option value="Wifi Clip V2">Wifi Clip V2</option>
            <option value="Servo">Servo</option>
            <option value="Logic Gate">Logic Gate</option>
            <option value="Toggle">Toggle</option>
            <option value="Touch">Touch</option>
            <option value="Laser">Laser</option>
            <option value="Solar">Solar</option>
            <option value="Heat">Heat</option>
            <option value="New TX-RX">New TX-RX</option>
            <option value="Old TX-RX">Old TX-RX</option>
            <option value="Magnet">Magnet</option>
            <option value="Record And Repeat">Record And Repeat</option>
            <option value="AI Chat">AI Chat</option>
            <option value="Clap">Clap</option>
            <option value="Tongee">Tongee</option>
        </select>
        <div id="spreadsheetWrapper" style="margin-top: 20px; display: none;"></div>
        <button id="saveBtn" style="display: none;">Save</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/handsontable@latest/dist/handsontable.full.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/handsontable@latest/dist/handsontable.full.min.css">

    <script type="module">
        // Import Firebase modules
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.6.5/firebase-app.js';
        import { getFirestore, collection, doc, writeBatch, getDocs } from 'https://www.gstatic.com/firebasejs/9.6.5/firebase-firestore.js';

        const firebaseConfig = {
  apiKey: "AIzaSyC0jbQgXGYAvX2znLQLflVfXUjREwl3JyY",
  authDomain: "officetest-92e0d.firebaseapp.com",
  projectId: "officetest-92e0d",
  storageBucket: "officetest-92e0d.appspot.com",
  messagingSenderId: "435215452631",
  appId: "1:435215452631:web:75cd4ea4fb4d07b65be392"
};


  // Initialize Firebase
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

let hotInstance; // Handsontable instance

document.getElementById('pcbSelect').addEventListener('change', async function () {
    const selectedPCB = this.value;

    if (selectedPCB) {
        await initializeSpreadsheet(selectedPCB);
        document.getElementById('spreadsheetWrapper').style.display = 'block';
        document.getElementById('saveBtn').style.display = 'block';

        // Fetch and display summary table
        displaySummaryTable(selectedPCB);
    } else {
        document.getElementById('spreadsheetWrapper').style.display = 'none';
        document.getElementById('saveBtn').style.display = 'none';
        document.getElementById('summaryContainer').style.display = 'none'; // Hide summary container if no PCB is selected
    }
});

async function initializeSpreadsheet(pcbName) {
    const container = document.getElementById('spreadsheetWrapper');

    // Destroy any existing Handsontable instance if it exists
    if (hotInstance) {
        hotInstance.destroy();
    }

    // Fetch existing data for the selected PCB from Firestore
    let allData = [];
    try {
        const querySnapshot = await getDocs(collection(db, 'dipaksirrecord', pcbName, 'data'));
        querySnapshot.forEach((doc) => {
            allData.push(doc.data());
        });
    } catch (error) {
        console.error("Error getting documents: ", error);
    }

    // Add a new row for new entries
    allData.push({
        date: new Date().toISOString().split('T')[0], // Current date
        quantity: ''
    });

    // Create a new Handsontable instance with read-only configuration
    hotInstance = new Handsontable(container, {
        data: allData,
        rowHeaders: true,
        colHeaders: ['Date', 'Quantity'],
        columns: [
            { data: 'date', readOnly: true },
            { data: 'quantity', type: 'numeric' }
        ],
        minSpareRows: 1,
        stretchH: 'all',
        height: 400,
        licenseKey: 'non-commercial-and-evaluation',
    });

    container.style.display = 'block'; // Display the spreadsheet container
}

async function displaySummaryTable(selectedPCB) {
    const summaryContainer = document.getElementById('summaryContainer');
    const summaryTable = document.getElementById('summaryTable');

    // Clear previous summary data
    summaryTable.innerHTML = '';

    // Fetch all existing data for the selected PCB from Firestore
    let allData = [];
    try {
        const querySnapshot = await getDocs(collection(db, 'dipaksirrecord', selectedPCB, 'data'));
        querySnapshot.forEach((doc) => {
            allData.push(doc.data());
        });
    } catch (error) {
        console.error("Error getting documents: ", error);
    }

    // Create object to accumulate quantities based on block names
    const pcbData = allData.reduce((acc, row) => {
        if (!acc[selectedPCB]) {
            acc[selectedPCB] = {
                quantity: 0
            };
        }
        acc[selectedPCB].quantity += row.quantity;
        return acc;
    }, {});

    // Create a table to display summary
    const table = document.createElement('table');
    const headerRow = document.createElement('tr');
    const headingPCB = document.createElement('th');
    headingPCB.textContent = selectedPCB;
    const headingQuantity = document.createElement('th');
    headingQuantity.textContent = 'Quantity';
    headerRow.appendChild(headingPCB);
    headerRow.appendChild(headingQuantity);
    table.appendChild(headerRow);

    // Create rows for each PCB with quantity
    Object.keys(pcbData).forEach(pcb => {
        const row = document.createElement('tr');
        const pcbCell = document.createElement('td');
        pcbCell.textContent = pcb;
        const quantityCell = document.createElement('td');
        quantityCell.textContent = pcbData[pcb].quantity;
        row.appendChild(pcbCell);
        row.appendChild(quantityCell);
        table.appendChild(row);
    });

    // Append table to summaryTable
    summaryTable.appendChild(table);

    // Show summary container
    summaryContainer.style.display = 'block';
}

document.getElementById('saveBtn').addEventListener('click', async function () {
    const selectedPCB = document.getElementById('pcbSelect').value;
    const data = hotInstance.getData();

    // Filter data to save
    const filteredData = data.filter(row => {
        return row && row[1] !== null && row[1] !== '' && !isNaN(row[1]);
    }).map(row => ({
        date: row[0],
        quantity: parseInt(row[1], 10)
    }));

    if (filteredData.length === 0) {
        alert('No valid data to save.');
        return;
    }

    try {
        const batch = writeBatch(db);

        filteredData.forEach(row => {
            const docRef = doc(db, 'dipaksirrecord', selectedPCB, 'data', row.date);
            batch.set(docRef, {
                date: row.date,
                quantity: row.quantity
            });
        });

        await batch.commit();
        console.log('Data saved successfully!', filteredData);
        alert('Data saved successfully!');

        // Show summary sheet after saving data
        displaySummary(selectedPCB, filteredData);
    } catch (error) {
        console.error('Error saving document: ', error);
        alert('Error saving document: ' + error.message);
    }
});

function displaySummary(selectedPCB, filteredData) {
    const summaryContainer = document.getElementById('summaryContainer');
    const summaryTable = document.getElementById('summaryTable');

    // Clear previous summary data
    summaryTable.innerHTML = '';

    // Create object to accumulate quantities based on block names
    const pcbData = filteredData.reduce((acc, row) => {
        if (!acc[selectedPCB]) {
            acc[selectedPCB] = {
                quantity: 0
            };
        }
        acc[selectedPCB].quantity += row.quantity;
        return acc;
    }, {});

    // Create a table to display summary
    const table = document.createElement('table');
    const headerRow = document.createElement('tr');
    const headingPCB = document.createElement('th');
    headingPCB.textContent = selectedPCB;
    const headingQuantity = document.createElement('th');
    headingQuantity.textContent = 'Quantity';
    headerRow.appendChild(headingPCB);
    headerRow.appendChild(headingQuantity);
    table.appendChild(headerRow);

    // Create rows for each PCB with quantity
    Object.keys(pcbData).forEach(pcb => {
        const row = document.createElement('tr');
        const pcbCell = document.createElement('td');
        pcbCell.textContent = pcb;
        const quantityCell = document.createElement('td');
        quantityCell.textContent = pcbData[pcb].quantity;
        row.appendChild(pcbCell);
        row.appendChild(quantityCell);
        table.appendChild(row);
    });

    // Append table to summaryTable
    summaryTable.appendChild(table);

    // Show summary container
    summaryContainer.style.display = 'block';
}

   </script>

</body>

</html>
