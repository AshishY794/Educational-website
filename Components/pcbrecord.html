<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WitBlox PCB Records</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <link rel="stylesheet" href="style.css">
  <style>
    .modal {
      display: none;
      position: fixed;
      z-index: 1;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.4);
    }

    .modal-content {
      background-color: #fefefe;
      margin: 15% auto;
      padding: 20px;
      border: 1px solid #888;
      width: 80%;
    }

    .close {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
    }

    .close:hover,
    .close:focus {
      color: black;
      text-decoration: none;
      cursor: pointer;
    }

    #bloxNameModal {
      display: none;
      /* Initially hide modal */
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.5);
      /* Semi-transparent background */
      z-index: 1000;
      /* Ensure modal appears above other content */
      overflow: auto;
      padding-top: 50px;
      /* Space for modal header */
    }

    .bloxNameModal-content {
      background-color: #fefefe;
      margin: 10% auto;
      /* Center modal on the screen */
      padding: 20px;
      border: 1px solid #888;
      width: 80%;
      /* 80% of the screen width */
      max-width: 600px;
      /* Maximum width of the modal */
    }

    .bloxNameModal-close {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
    }

    .bloxNameModal-close:hover,
    .bloxNameModal-close:focus {
      color: black;
      text-decoration: none;
      cursor: pointer;
    }

    #bloxNameForm {
      max-height: 400px;
      /* Limit height of the form within the modal */
      overflow-y: auto;
      /* Enable scrolling if form exceeds max height */
    }
    h2{
      text-align: center;
      color: grey;
      font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
      font-size: 15px;
    }
  </style>
</head>

<body>
  <h1>WitBlox PCB's Records</h1>
  <!-- Container for the spreadsheet -->
   <h2>Available PCB In Stock</h2>
  <div id="spreadsheetWrapper" class="spreadsheet-wrapper"></div>

  <!-- Container for buttons -->
  <div class="button-area">
    <button id="csvDownloadBtn">Download CSV</button>
  </div>
  <br><br>

  <div id="bloxNameModal" class="modal">
    <div class="modal-content">
      <span class="close">&times;</span>
      <h2>Select Blox Names</h2>
      <form id="bloxNameForm">
        <!-- Checkbox options will be dynamically inserted here -->
      </form>
      <button id="confirmBloxNamesBtn">Add</button>
    </div>
  </div>

  <center>
    <H1>Add PCB Data</H1>

    <!-- Date Picker -->
    <label for="datepicker">Select Date:</label>
    <input type="text" id="datepicker" placeholder="Select date...">
  </center>
  <!-- Button to open spreadsheet -->
  <button id="openSpreadsheetBtn">Add Data</button>

  <!-- Container for the spreadsheet -->
  <div id="spreadsheetContainer">
    <button id="addBloxBtn" style="position: absolute; bottom: 10px; right: 10px; margin-bottom: 20px">Add Blox</button>

  </div>

  <!-- Save, Reset, Show, and Cancel buttons -->
  <button id="saveDataBtn">Save</button>
  <button id="resetFormBtn" style="display: none;">Reset</button>
  <button id="cancelSpreadsheetBtn">Cancel</button>

  <h1>See All Records</h1>
  <center>
    <!-- Dropdown for saved dates -->
    <label for="dateDropdown">Select Saved Date:</label>
    <select id="dateDropdown">
      <option value="">Select date...</option>
    </select>
  </center>
  <button id="showDataBtn">Show</button>
  <a href="../index.html"><button id="homebutton">Home</button></a>

  <!-- Handsontable script -->
  <script src="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.6.5/firebase-app.js';
    import { getFirestore, collection, doc, setDoc, getDoc, getDocs } from 'https://www.gstatic.com/firebasejs/9.6.5/firebase-firestore.js';

    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyC0jbQgXGYAvX2znLQLflVfXUjREwl3JyY",
      authDomain: "officetest-92e0d.firebaseapp.com",
      projectId: "officetest-92e0d",
      storageBucket: "officetest-92e0d.appspot.com",
      messagingSenderId: "435215452631",
      appId: "1:435215452631:web:75cd4ea4fb4d07b65be392"
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // // Declare global variables
    // let hot; // Handsontable instance
    let selectedDate = ""; // Variable to store selected date


    // Declare global variables
    let hot; // Handsontable instance
    let selectedBloxNames = []; // Variable to store selected blox names

    // Function to initialize Handsontable instance
    function openSpreadsheet() {
      const container = document.getElementById('spreadsheetContainer');

      // Destroy any existing Handsontable instance if it exists
      if (hot) {
        hot.destroy();
      }

      // Create a new Handsontable instance
      hot = new Handsontable(container, {
        data: [[]], // Initial data array
        rowHeaders: true,
        colHeaders: ['Blox Name', 'Input', 'Output', 'Reminder'],
        columns: [
          {
            data: 'bloxName', editor: 'dropdown', // Use dropdown editor for bloxName
            // Dropdown options are updated dynamically
            source: selectedBloxNames
          },
          { data: 'input', type: 'numeric' },
          { data: 'output', type: 'numeric' },
          { data: 'reminder', readOnly: true }
        ],
        minSpareRows: 1, // Allow adding new rows
        contextMenu: true,
        manualColumnResize: true,
        manualRowResize: true,
        stretchH: 'all',
        height: 400,
        licenseKey: 'non-commercial-and-evaluation',
        afterChange: function (changes, source) {
          if (changes) {
            changes.forEach(([row, prop, oldVal, newVal]) => {
              if (prop === 'input' || prop === 'output') {
                const input = this.getDataAtRowProp(row, 'input');
                const output = this.getDataAtRowProp(row, 'output');
                if (input != null && output != null) {
                  const reminder = input - output;
                  this.setDataAtRowProp(row, 'reminder', reminder);
                }
              }
            });
          }
        }
      });

      // Show the Cancel button and hide the Add Data button
      document.getElementById('openSpreadsheetBtn').style.display = 'none';
      document.getElementById('cancelSpreadsheetBtn').style.display = 'block';
      document.getElementById('resetFormBtn').style.display = 'block'; // Show the Reset button
      document.getElementById('saveDataBtn').style.display = 'block'; // Show the Save button
      container.style.display = 'block'; // Display the spreadsheet container
    }



    // Function to populate blox name modal with checkboxes
    function populateBloxNameModal() {
      const modal = document.getElementById('bloxNameModal');
      const form = document.getElementById('bloxNameForm');

      // Replace this with your actual blox names data source
      const bloxNames = ['Power', 'Lamp', 'Buzzer', 'Invert', 'Dark', 'Distance', 'IR', 'Motor Driver', 'Wire Tap', 'Button'];

      // Clear previous checkboxes
      form.innerHTML = '';

      bloxNames.forEach((bloxName) => {
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.name = 'bloxName';
        checkbox.value = bloxName;
        checkbox.id = bloxName;

        const label = document.createElement('label');
        label.htmlFor = bloxName;
        label.appendChild(document.createTextNode(bloxName));

        form.appendChild(checkbox);
        form.appendChild(label);
        form.appendChild(document.createElement('br'));
      });

      // Show the modal
      modal.style.display = 'block';

      // Close modal if close button or outside modal is clicked
      modal.getElementsByClassName('close')[0].onclick = function () {
        modal.style.display = 'none';
      };

      // Handle Add button click in the modal
      document.getElementById('confirmBloxNamesBtn').onclick = function () {
        selectedBloxNames = []; // Clear previous selections
        const checkboxes = document.getElementsByName('bloxName');
        checkboxes.forEach((checkbox) => {
          if (checkbox.checked) {
            selectedBloxNames.push(checkbox.value);
          }
        });

        // Update Handsontable column with selected blox names
        updateBloxNameColumn(selectedBloxNames);

        // Close the modal
        modal.style.display = 'none';
      };
    }

    // Function to update the Handsontable column with selected blox names
    function updateBloxNameColumn(selectedBloxNames) {
      if (hot) {
        hot.updateSettings({
          columns: [
            {
              data: 'bloxName', editor: 'dropdown',
              source: selectedBloxNames
            },
            { data: 'input', type: 'numeric' },
            { data: 'output', type: 'numeric' },
            { data: 'reminder', readOnly: true }
          ]
        });
      } else {
        console.error('Handsontable instance not found');
      }
    }

    // Event listener for Add Data button click
    document.getElementById('openSpreadsheetBtn').onclick = function () {
      populateBloxNameModal();
    };

    
    document.getElementById('addBloxBtn').onclick = function () {
      populateBloxNameModal();
    };


    // Function to save data to Firestore
    async function saveData() {
      try {
        if (!selectedDate) {
          alert("Please select a date.");
          return;
        }

        const data = hot.getData(); // Get all data from Handsontable instance
        const flattenedData = flattenData(data); // Flatten the nested array data

        const docRef = doc(db, `sheetData/${selectedDate}/`); // Reference to Firestore document

        // Save data to Firestore document
        await setDoc(docRef, { data: flattenedData });

        alert("Data saved to Firestore under " + selectedDate); // Show a message to the user
        resetForm(); // Reset the form after saving
      } catch (error) {
        console.error("Error adding document: ", error);
        alert("Failed to save data to Firestore. Please try again.");
      }
    }




    // Function to reset the form
    function resetForm() {
      // Reset selectedDate variable
      selectedDate = "";

      // Clear the flatpickr datepicker
      datepicker.clear();

      // Hide Cancel button and show Add Data button
      document.getElementById('openSpreadsheetBtn').style.display = 'block';
      document.getElementById('cancelSpreadsheetBtn').style.display = 'none';
      document.getElementById('resetFormBtn').style.display = 'none'; // Hide the Reset button
      document.getElementById('saveDataBtn').style.display = 'none'; // Show the Save button


      // Hide the spreadsheet container
      document.getElementById('spreadsheetContainer').style.display = 'none';

      // Destroy Handsontable instance if it exists
      if (hot) {
        hot.destroy();
        hot = null; // Reset hot instance to null
      }
    }




    // Function to flatten nested array data
    function flattenData(data) {
      const flattenedData = [];

      for (let row of data) {
        const flatRow = {
          bloxName: row[0],
          input: row[1],
          output: row[2],
          reminder: row[3]
        };
        flattenedData.push(flatRow);
      }

      return flattenedData;
    }





    // Function to populate dropdown with saved dates
    async function populateDropdown() {
      const dropdown = document.getElementById('dateDropdown');
      dropdown.innerHTML = ""; // Clear existing options

      try {
        const querySnapshot = await getDocs(collection(db, 'sheetData'));
        querySnapshot.forEach((doc) => {
          const date = doc.id;
          const option = document.createElement('option');
          option.value = date;
          option.textContent = date.replaceAll('_', '/'); // Format date for display
          dropdown.appendChild(option);
        });
      } catch (error) {
        console.error("Error getting documents: ", error);
        alert("Failed to retrieve saved dates from Firestore.");
      }
    }





    // Function to display data for selected date
    async function displaySelectedDate() {
      const selected = document.getElementById('dateDropdown').value;

      try {
        const docRef = doc(db, `sheetData/${selected}/`);
        const docSnapshot = await getDoc(docRef); // Use getDoc to fetch document snapshot

        if (docSnapshot.exists()) {
          const data = docSnapshot.data().data;
          if (hot) {
            hot.loadData(data); // Load data into Handsontable instance if it exists
            selectedDate = selected; // Update selectedDate
          } else {
            openSpreadsheet(); // Reinitialize spreadsheet view if hot instance is null
            hot.loadData(data); // Load data into Handsontable instance
            selectedDate = selected; // Update selectedDate
          }
        } else {
          alert("No data found for selected date.");
        }
      } catch (error) {
        console.error("Error getting document: ", error);
        alert("Failed to retrieve data from Firestore.");
      }
    }




    // Function to cancel and close the spreadsheet
    function cancelSpreadsheet() {
      // Check if Handsontable instance exists
      if (hot) {
        hot.destroy(); // Destroy Handsontable instance
        hot = null; // Reset hot instance to null
      }

      resetForm(); // Reset the form (show Add Data button and hide Cancel button)
    }

    // Initialize flatpickr for date picker
    const datepicker = flatpickr("#datepicker", {
      dateFormat: "d/m/Y", // Format: day/month/year
      onChange: function (selectedDates, dateStr, instance) {
        selectedDate = dateStr.replaceAll('/', '_'); // Update selectedDate variable with underscores instead of slashes
        console.log("Selected date:", selectedDate);
      }
    });

    // Event listener for when the DOM is fully loaded
    document.addEventListener('DOMContentLoaded', function () {
      const openBtn = document.getElementById('openSpreadsheetBtn');
      const saveBtn = document.getElementById('saveDataBtn');
      const resetBtn = document.getElementById('resetFormBtn');
      const showBtn = document.getElementById('showDataBtn'); // Show button
      const cancelBtn = document.getElementById('cancelSpreadsheetBtn'); // Cancel button

      openBtn.addEventListener('click', openSpreadsheet);
      saveBtn.addEventListener('click', saveData);
      resetBtn.addEventListener('click', resetForm);
      showBtn.addEventListener('click', displaySelectedDate); // Attach showDataBtn click event
      cancelBtn.addEventListener('click', cancelSpreadsheet); // Attach cancelSpreadsheet click event

      // Populate dropdown with saved dates on page load
      populateDropdown();
    });






    // for reminder data show in top 
    // Declare global variable
    let hotInstance; // Handsontable instance

    async function initializeSpreadsheet() {
  const container = document.getElementById('spreadsheetWrapper');

  // Destroy any existing Handsontable instance if it exists
  if (hotInstance) {
    hotInstance.destroy();
  }

  // Fetch data from Firestore
  let allData = [];
  try {
    const querySnapshot = await getDocs(collection(db, 'sheetData'));
    const bloxData = {};

    querySnapshot.forEach((doc) => {
      const data = doc.data().data;
      data.forEach(row => {
        if (row.bloxName) {
          if (row.reminder != null) {
            if (bloxData[row.bloxName]) {
              bloxData[row.bloxName] += row.reminder;
            } else {
              bloxData[row.bloxName] = row.reminder;
            }
          } else {
            // Use input value when reminder is null or undefined
            if (bloxData[row.bloxName]) {
              bloxData[row.bloxName] += row.input;
            } else {
              bloxData[row.bloxName] = row.input;
            }
          }
        }
      });
    });

    // Convert bloxData to an array of objects
    allData = Object.keys(bloxData).map(bloxName => ({
      bloxName,
      reminder: bloxData[bloxName]
    }));
  } catch (error) {
    console.error("Error getting documents: ", error);
  }

  // Create a new Handsontable instance with read-only configuration
  hotInstance = new Handsontable(container, {
    data: allData, // Use aggregated data
    rowHeaders: true,
    colHeaders: ['Blox Name', 'Reminder'],
    columns: [
      { data: 'bloxName' },
      { data: 'reminder', type: 'numeric' }
    ],
    minSpareRows: 1, // Allow adding new rows
    readOnly: true, // Make the spreadsheet view-only
    stretchH: 'all',
    height: 400,
    licenseKey: 'non-commercial-and-evaluation'
  });

  container.style.display = 'block'; // Display the spreadsheet container
}

    // Function to convert Handsontable data to CSV
    function convertToCSV() {
      const data = hotInstance.getData();
      const csvContent = "data:text/csv;charset=utf-8,"
        + data.map(row => row.join(",")).join("\n");

      const encodedUri = encodeURI(csvContent);
      const link = document.createElement("a");
      link.setAttribute("href", encodedUri);
      link.setAttribute("download", "blox_availability.csv");
      document.body.appendChild(link); // Required for Firefox
      link.click(); // Trigger the download
    }

    // Event listener for when the DOM is fully loaded
    document.addEventListener('DOMContentLoaded', function () {
      initializeSpreadsheet();

      // Event listener for Download CSV button
      document.getElementById('csvDownloadBtn').addEventListener('click', convertToCSV);
    });



    //     // Function to populate blox name modal with checkboxes
    // function populateBloxNameModal() {
    //   const modal = document.getElementById('bloxNameModal');
    //   const form = document.getElementById('bloxNameForm');

    //   // Replace this with your actual blox names data source
    //   const bloxNames = ['Blox A', 'Blox B', 'Blox C', 'Blox D', 'Blox E'];

    //   // Clear previous checkboxes
    //   form.innerHTML = '';

    //   bloxNames.forEach((bloxName) => {
    //     const checkbox = document.createElement('input');
    //     checkbox.type = 'checkbox';
    //     checkbox.name = 'bloxName';
    //     checkbox.value = bloxName;
    //     checkbox.id = bloxName;

    //     const label = document.createElement('label');
    //     label.htmlFor = bloxName;
    //     label.appendChild(document.createTextNode(bloxName));

    //     form.appendChild(checkbox);
    //     form.appendChild(label);
    //     form.appendChild(document.createElement('br'));
    //   });

    //   // Show the modal
    //   modal.style.display = 'block';

    //   // Close modal if close button or outside modal is clicked
    //   modal.getElementsByClassName('close')[0].onclick = function() {
    //     modal.style.display = 'none';
    //   };

    //   // Handle Add button click in the modal
    //   document.getElementById('confirmBloxNamesBtn').onclick = function() {
    //     const selectedBloxNames = [];
    //     const checkboxes = document.getElementsByName('bloxName');
    //     checkboxes.forEach((checkbox) => {
    //       if (checkbox.checked) {
    //         selectedBloxNames.push(checkbox.value);
    //       }
    //     });

    //     // Display selected blox names in a separate sheet or list
    //     displaySelectedBloxNames(selectedBloxNames);

    //     // Close the modal
    //     modal.style.display = 'none';
    //   };
    // }

    // // Function to display selected blox names in a separate sheet or list
    // function displaySelectedBloxNames(selectedBloxNames) {
    //   const bloxNamesList = document.getElementById('bloxNamesList');

    //   // Check if bloxNamesList exists before manipulating it
    //   if (bloxNamesList) {
    //     bloxNamesList.innerHTML = '';

    //     selectedBloxNames.forEach((bloxName) => {
    //       const li = document.createElement('li');
    //       li.textContent = bloxName;
    //       bloxNamesList.appendChild(li);
    //     });
    //   } else {
    //     console.error('bloxNamesList element not found');
    //   }
    // }

    // // Event listener for Add Data button click
    // document.getElementById('openSpreadsheetBtn').onclick = function() {
    //   populateBloxNameModal();
    // };

  </script>


</body>

</html>